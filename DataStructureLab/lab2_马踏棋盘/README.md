## 数据结构实验2：马踏棋盘

### （1） 问题描述

设计一个国际象棋的马踏棋盘的演示程序.

### （2） 设计要求

1） 程序的输入：设计程序按要求输入马的初始位置（相应的坐标）。

2） 程序的输出：程序的设计完成后应给出马从初始位置走遍棋盘的过程，并按照求出的行走路线顺序，将数字1，2，…，64依次填入一个8╳8的方阵并输出。

### （3） 数据结构

  本设计使用的数据结构是栈，利用顺序栈来实现。

### （4） 分析与实现

#### 分析要求：

输入马的初始位置（相应的坐标），输出马走遍棋盘的过程。

#### 算法设计：

使用栈作为数据结构来实现马踏棋盘，将棋盘作为二维数组存储，将马能走的八个方向存在一维数组中，并且将代码各个部分模块化分为初始化棋盘，马踏棋盘，打印棋盘，函数主入口四部分，在马踏棋盘中使用栈递归实现遍历棋盘，若马能走下一步则入栈，若马无法走下一步则回溯到有其他选项的上一步，依次将所有可能输出。

#### 代码：

```c++
#include<stdio.h>
#include<stdlib.h>
int chess[8][8]={0};        //定义棋盘
int move[8][2]={{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2}};     //遍历下一个日的位置
int cnt=1;                            //记录马踏的每一步
int sum=1 ;                           //记录解的个数

void print()
{
	int i,j;
	printf("\n");
	printf("%d:\n",sum++);
	for(i=0;i<8;i++)
	{
		for(j=0;j<8;j++)
			printf("%5d",chess[i][j]);
		printf("\n");
	}
}

void horse(int x,int y)
{
	int a,b,i;
	for(i=0;i<8;i++)
	{
		a=x+move[i][0];
		b=y+move[i][1];
		if(a>=0 && a<8 && b>=0 && b<8 && !chess[a][b])
		{
			chess[a][b]=++cnt;
			if(cnt<64) horse(a,b);
			else  print();   
			chess[a][b]=0;
			cnt--;
		}
	}
}

void Init()
{
	int i,j;
	for(i=0; i<8; i++)
	{
		for(j=0; j<8; j++)
		chess[i][j]=0;
	}
	cnt=1;
}

int main(void)
{
    int i,j;
    printf("请以(x,y)的形式输入马的初始位置(注意1<=x,y<=8):");
    scanf("(%d,%d)", &i, &j);
    if(i>=1 && i <=8 & j>=1 && j<=8){
        Init();
	    chess[i-1][j-1]=1;     //直接将马置于该位置，该位置为第一步
	    horse(i-1,j-1);	
    } else {
        printf("输入格式有误，请检查");
    }
	return 0;
}

```

### （5） 运行与测试

####   input 

```c++
(1,1)
```

#### output 

结果种类多，输出较长故只能截图展示

![image-20211220184920084](C:\Users\76104\AppData\Roaming\Typora\typora-user-images\image-20211220184920084.png)

### （6） 总结与思考

#### 使用贪心算法优化回溯过程

题目考察DFS的应用，但是只使用回溯算法会导致输出非常慢，马的不同走法有不同的策略，使用贪心算法进行非递减排序可以优化马的下一步选择，从而减少回溯所消耗的性能，因此可以将下一步集合中的点进行排序，选出选择最少的点。

